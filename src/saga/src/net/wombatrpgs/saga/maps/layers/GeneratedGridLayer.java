/**
 *  TileLayer.java
 *  Created on Nov 29, 2012 3:51:55 PM for project rainfall-libgdx
 *  Author: psy_wombats
 *  Contact: psy_wombats@wombatrpgs.net
 */
package net.wombatrpgs.saga.maps.layers;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;

import net.wombatrpgs.saga.core.MGlobal;
import net.wombatrpgs.saga.maps.Level;
import net.wombatrpgs.saga.maps.Tile;
import net.wombatrpgs.saga.maps.events.MapEvent;
import net.wombatrpgs.saga.screen.TrackerCam;

/**
 * A grid layer that was generated by algorithm. Uses an internal array of tiles
 * to keep track of passability information.
 */
public class GeneratedGridLayer extends GridLayer {
	
	protected Tile[][] tileData;
	
	/**
	 * Creates a new grid layer with a parent level and z. This is expected for
	 * subclasses that will manipulate their own tile data.
	 */
	public GeneratedGridLayer(Level parent, float z) {
		super(parent, z);
	}
	
	/**
	 * Creates a new object layer with a parent level and group of objects.
	 * Expects to be mutilated and pretty much bossed around by a map generator.
	 * @param 	parent			The parent level of the layer
	 * @param	tileData		The actual info about tiles on this layer
	 * @param	z				The z-depth of this layer
	 */
	public GeneratedGridLayer(Level parent, Tile[][] tileData, float z) {
		this(parent, z);
		this.tileData = tileData;
	}

	/**
	 * @see net.wombatrpgs.saga.maps.layers.Layer#render
	 * (com.badlogic.gdx.graphics.OrthographicCamera)
	 */
	@Override
	public void render(OrthographicCamera camera) {
		dumbRender(camera);
	}

	/**
	 * @see net.wombatrpgs.saga.maps.layers.Layer#isPassable(MapEvent, int, int)
	 */
	@Override
	public boolean isPassable(MapEvent actor, final int x, final int y) {
		return	(x >= 0 && x < parent.getWidth()) &&
				(y >= 0 && y < parent.getHeight()) &&
				(tileData[y][x] == null || tileData[y][x].isPassable());
	}
	
	/**
	 * Checks if a tile at the given location is see-through. Does not check
	 * for out of bounds.
	 * @param	tileX			The x-coord of the tile to check (in tiles)
	 * @param	tileY			The y-coord of the tile to check (in tiles)
	 * @return					True if tile is transparent, false otherwise
	 */
	public boolean isTransparentAt(int tileX, int tileY) {
		return tileData[tileY][tileX] == null ||
				tileData[tileY][tileX].isTransparent();
	}
	
	/**
	 * Does an extremely inefficient rendering pass.
	 * @param	cam				The camera to render with
	 */
	protected void dumbRender(OrthographicCamera camera) {
		TrackerCam cam  = MGlobal.screens.peek().getCamera();
		int startX = (int) Math.floor((cam.position.x - MGlobal.window.getWidth()/2.f) / parent.getTileWidth());
		int startY = (int) Math.floor((cam.position.y - MGlobal.window.getHeight()/2.f) / parent.getTileHeight());
		int endX = (int) Math.ceil((cam.position.x + MGlobal.window.getWidth()/2.f) / parent.getTileWidth());
		int endY = (int) Math.ceil((cam.position.y + MGlobal.window.getHeight()/2.f) / parent.getTileHeight());
		if (startX < 0) startX = 0;
		if (startY < 0) startY = 0;
		if (endX > parent.getWidth()) endX = parent.getWidth();
		if (endY > parent.getHeight()) endY = parent.getHeight();
		boolean shaders = MGlobal.graphics.isShaderEnabled();
		Color old = parent.getBatch().getColor().cpy();
		Color trans = parent.getBatch().getColor().cpy();
		trans.a = .5f;
		parent.getBatch().begin();
		for (int x = startX; x < endX; x += 1) {
			for (int y = startY; y < endY; y += 1) {
				float atX = parent.getTileWidth() * x;
				float atY = parent.getTileHeight() * y;
				if (tileData[y][x] != null) {
					if (shaders) {
						tileData[y][x].renderLocal(camera, parent.getBatch(), atX, atY);
					} else {
						if (MGlobal.hero.inLoS(x, y)) {
							tileData[y][x].renderLocal(camera, parent.getBatch(), atX, atY);
						} else if (MGlobal.hero.seen(x, y)) {
							parent.getBatch().setColor(trans);
							tileData[y][x].renderLocal(camera, parent.getBatch(), atX, atY);
							parent.getBatch().setColor(old);
						}
					}
				}
			}
		}
		parent.getBatch().end();
		parent.getBatch().setColor(old);
	}
}
